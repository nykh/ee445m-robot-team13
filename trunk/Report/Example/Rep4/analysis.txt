\paragraph{Give the calculations (equations and results) you used to estimate the cutoff frequencies for your HPF and 
LPF (Preparation 1)? How did the measured frequency response compare to the estimations (procedure 2)?}

We wanted the LPF's cutoff to be $400\,Hz$ since we set the sampling rate to $2\,kHz$. Although cutoff is much lower than the maximum allowed
frequency according to Nyquist's theorem, we chose such a low cutoff to be improve performance and prevent aliasing.

Equations:
For a Butterworth 2 Pole Sallen-key LPF, $C_1 = 141.4\,\mu F$ and $C_2 = 70.7\,\muF$ and $R = 10\,k\Omega$ , $f_c = 1\,Hz$.
To change fc to $400\,Hz$, the new capacitor values can be calculated by $C_1' = \frac{C_1}{2 \pi f_c} = 0.0563\,\mu F$ and
$C_2' = C_1'/2 = 0.0281\,\mu F$. If we multiply the capacitors by $0.344484$ to set $C_1 = 20\,nF$ and $C_2 = 10\,nF$, to keep $f_c$
the same as $400\,Hz$, we should also divide the resistance by $0.344484$ that results in $R = 28.131 k\Omege$.
Finally, we chose the resistance as $27\,k\Omega$ which resulted in a $f_c$ of $416.75\,Hz$.

After doing procedure do we find the cutoff frequency to be around $410\,Hz$. (frequency at which gain was 0.707) This difference is probably due to inaccuracy of resistance and capacitance of the filter components.
 
\paragraph{Explain how you measured maximum bandwidth (procedure 5). What was the limiting factor affecting 
bandwidth?}

We added a variable that starts by 0 and is incremented everytime ADC fails to put the sampled data into the FIFO. We also added a separated variable that starts by 0 and is incremented everytime Producer fails has to disregard an old data that is still not displayed by the Display thread. Both variables should be 0 through the test. We started by a low Sampling rate by $2000\,Hz$ and continuously increased it, and read both DataLost variables with or without FIR filter being on. As soon as there was a DataLost in either variable, the bandwidth was determined as the previous step with no DataLost.

Regardless of FIR filter being on or off, liming factor was the display thread as only that variable was incremented as soon as we chose a sampling rate more than the bandwidth. We were able to increase bandwidth by optimizing display functions. (But the system was still limited by the display thread)

We also tested the system with display off and the bandwidth was much higher than before.
 
\paragraph{What is the expected FFT output if the input is a squarewave?}
 
Squarewave is the sum of sinewaves with frequencies of $(2n+1)f$ for all $n = 0,1,2,3,\cdots$ where $f = \frac{1}{period of the squarewave}$

Therefore, fft should be like spikes at certain frequencies.
 
\paragraph{Look at the noise in your digital samples when it is very quiet? What type of noise is it? }

The noise when we don't move the distance sensor is sudden spikes at random times. (we used distance sensor, not microphone)
 
 \paragraph{We made a big fuss over jitter in labs 2 and 3. Can you estimate the jitter in your ADC samples?}
 
 Jitter is 0, since we are using a timer to trigger ADC capture.
 
\paragraph{Prove your FIR implementation can not overflow.}

 largest coefficient of the FIR filter $ = 8578 < 2^14$
 The number of points $ = 51 < 2^6 $
 Maximum number of ADC result $ = 4095 < 2^12 $
 
 Maximum total size $ < 2^6 \cdot 2^14 \cdot 2^12 = 2 ^ 32 $
 Therefore, the sum fits in a 32-bit unsigned long variable
 
\paragraph{Look at the symmetry in the $h[51]$ coefficients in the example FIR design. How could you rewrite the 
following filter equation to reduce the number of multiplies from 51 to 26?}

\lstinline{
y[i]= (h[0]*x[i]+h[1]*x[i-1]+h[2]*x[i-2]+?h[50]*x[i-50])/256;
y[i] = ( h[0]*(x[i]+x[i-50]) + h[1]*(x[i-1]+x[i-49] + ... h[25]*(x[i-24]+x[i-26]) + h[26]*x[i-26] ) / 256;
}
\paragraph{If your system executed the FIR filter using the multiply and accumulate instruction (MLA), you can skip 
this question. Explain how the MLA instruction could have made your filter execute faster? If you were to have 
used the MLA instruction, would it have been more accurate?}

The compiler used MLA in the filter implementation,.

MLA is faster than using consecutive MUL and ADD instruction. So, it can potentially speed up the FIlter execution time by a factor of 2.
However, since we have a for loop in the system, the effect of the otther instructions cannot be neglected, so execution time will practically increase, but not increase by a factor of 2.
